package com.marklynch.weather.data

import android.content.Context
import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.test.core.app.ApplicationProvider
import com.marklynch.weather.data.manuallocation.ManualLocation
import com.marklynch.weather.data.manuallocation.ManualLocationDAO
import com.marklynch.weather.dependencyinjection.activityModules
import com.marklynch.weather.dependencyinjection.appModules
import com.marklynch.weather.dependencyinjection.testWeatherDatabase
import com.marklynch.weather.utils.observeXTimes
import com.marklynch.weather.utils.randomAlphaNumeric
import junit.framework.Assert
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.koin.standalone.StandAloneContext
import org.koin.standalone.get
import org.koin.test.KoinTest
import java.io.IOException
import kotlin.random.Random

class WeatherDatabaseTest : KoinTest {
    private lateinit var db: WeatherDatabase
    private lateinit var manualLocationDAO: ManualLocationDAO

    @get:Rule
    val rule = InstantTaskExecutorRule()

    @Before
    fun setup() {

        val moduleList =
            appModules +
                    activityModules +
                    testWeatherDatabase

        StandAloneContext.loadKoinModules(moduleList)
        
        db = get()
        manualLocationDAO = db.getManualLocationDao()
    }

    @After
    @Throws(IOException::class)
    fun closeDb() {
        db.close()
    }

    private fun insertAndCheckLocation(): ManualLocation {
        val displayName = randomAlphaNumeric(5)
        val lat = Random.nextDouble()
        val lon = Random.nextDouble()

        val toInsertInDB = ManualLocation(0, displayName, lat, lon)
        val autoGeneratedId = manualLocationDAO.insert(toInsertInDB)
        val expected = ManualLocation(autoGeneratedId, displayName, lat, lon)
        val actual = manualLocationDAO.getManualLocationById(autoGeneratedId)

        assertEquals(expected, actual)

        return actual
    }

    @Test
    fun testInsertAndGetManualLocationById() {
        insertAndCheckLocation()
    }

    @Test
    fun testInsertUpdateAndGetManualLocationById() {

        //Insert
        val insertedManualLocation = insertAndCheckLocation()

        //Update
        val updateDisplayName = randomAlphaNumeric(5)
        val updateLat = Random.nextDouble()
        val updateLon = Random.nextDouble()

        val toUpdateInDB = ManualLocation(
            insertedManualLocation.id,
            updateDisplayName,
            updateLat,
            updateLon
        )
        manualLocationDAO.update(toUpdateInDB)
        val expected2 = ManualLocation(
            insertedManualLocation.id,
            updateDisplayName,
            updateLat,
            updateLon
        )
        val actual2 = manualLocationDAO.getManualLocationById(insertedManualLocation.id)

        assertEquals(expected2, actual2)
    }

    @Test
    fun testInsertDeleteAndGetManualLocationById() {

        //Insert
        val insertedManualLocation = insertAndCheckLocation()

        //Delete
        manualLocationDAO.delete(insertedManualLocation)
        val actual2 = manualLocationDAO.getManualLocationById(insertedManualLocation.id)
        assertEquals(null, actual2)
    }

    @Test
    fun testInsertandSelectAllManualLocationById() {

        //Select all
        val manualLocationsLiveData = manualLocationDAO.getManualLocationLiveData()

        //Insert
        val insertedManualLocation = insertAndCheckLocation()

        var observations = 0
        manualLocationsLiveData.observeXTimes(1) {
            observations++
            Assert.assertEquals(insertedManualLocation, it[0])
        }

        Assert.assertEquals(1, observations)
    }
}